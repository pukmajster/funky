/*************************************************************
 *
 * FUNKY KEY VALUES
 *
 * json2vdf()
 * Takes a JSON object and spits out a VDF string
 *
 ************************************************************/

type VdfFormattingOptions = {
  indentValues: boolean
  watermark: boolean
  arrayIndexingName?: string
}

const defaultVdfFormattingOptions: VdfFormattingOptions = {
  indentValues: false,
  watermark: false,
  arrayIndexingName: 'file'
}

export function json2vdf(json: Object, rootName: string, options?: Partial<VdfFormattingOptions>) {
  const opts = { ...defaultVdfFormattingOptions, ...options } as VdfFormattingOptions

  let output = '// File generated by funky\n\n'

  function vdfIndent(level: number) {
    return '\t'.repeat(level)
  }

  function print(level: number, str: string) {
    output += vdfIndent(level) + str + '\n'
  }

  output += `"${rootName}"\n{\n`

  function recursivelySerialize(obj: Object, depth: number = 1) {
    for (const key in obj) {
      const value = obj[key]

      if (typeof value === 'object') {
        output += vdfIndent(depth) + `"${key}"` + '\n'
        output += vdfIndent(depth) + '{\n'
        recursivelySerialize(value, depth + 1)
        output += vdfIndent(depth) + '}\n'

        // TODO: Add support for array indexing
      } else {
        let formattedValue = value

        switch (typeof value) {
          case 'string':
            break

          case 'number':
            formattedValue = value.toString()
            break

          case 'boolean':
            formattedValue = value ? 'true' : 'false'
            break

          default:
            console.error(`[FKV json2vdf] Unsupported value type: ${typeof value}`)
            formattedValue = 'undefined'
            break
        }

        let spacingMethod = opts.indentValues ? '\t' : ' '
        output += `${vdfIndent(depth)}"${key}"${spacingMethod}"${formattedValue}"\n`
      }
    }
  }

  recursivelySerialize(json)

  // Close the root object
  output += '}\n'

  return output
}
